## Задача
Требуется привести описания, почему могут возникать те или иные проблемы в коде на уровне классов и всего приложения.  
Конкретно здесь делаю это на основе уже имеющихся у меня знаний.


## Примеры

_Уровень классов_  

**1 Класс слишком большой или создается слишком много его инстансов**

Класс utills для различных обработчиков. Сначала туда выносились методы которые были
в 2-3 обработчиках при их общем числе в 5-10, потом число обработчиков разросталось И мы встретились с пересечением множеств. Какие-то методы использовались в 10-20 классах,
но когда появлялись методы, которые будут использоваться в 2-3, то их снова добавляли в класс А утилит, т.к. зависимость от него уже была в новом классе Б, но так же в класс А добавлялись методы,
используемые еще только в 2-3 классах Т.к. таких групп по 2-3 класса
с общими методами было много класс утилит разросся. Теперь он требует рефакторинг
для разделения на несколько других и импорта только требуемых в конкретных классов.
Что бы не увеличивать число полей в классах, которые завязаны на классы утилит, стоит сделать классы обертки UtillsForABC и добавлять их в соответсвующие классы А, В, С,
взамен старого класса утилит.
A B UtillsForABC уже будут собраны те более мелкие классы утилит, которые получатся из изначального класса Utills.
При этом возникнет проблема, что если потребуется добавить снова новый утилитный функционал,
касающийся нескольких десятков классов, то придется затрагивать большее число классов,
тех самых агрегаторов UtillsFor...


**2 Класс слишком маленький или делает слишком мало.**

Сложно придумать пример для такого :).

В целом, можно говорить о классе,
который видим только в рамках определенного пакета, а класс, который его в себе содержит уже как поле,
доступен извне.
Вероятно можем говорить о каком-то утилитном классе,
функционал которого стоит вынести
в сами объекты.
Например NameWriter, если говорить о синтетическом примере. Но он являл бы собой Visitor,
что вполне неплохо.
Так же можно говорить об очень специфицированном классе,
вместо того,
что бы использовать класс А, задав в нем соответсвующие значения, создается класс В, в котором эти значения будут всегда, например был Gender, а создали Female/Male,
но этот пример я так же не могу назвать совершенно плохим,
разве что
это помешает в некотором switch case при увеличении множества значений. Сложный пример.

**3 В классе есть метод, который выглядит более подходящим для другого класса.**

Например printstatistic() в классе Warrior, больше подойдет для класса Printer,
или даже непосредственно Statistic Но, т.к. класс Statistic использовался
как поле в классе Warrior, то остановился на такой реализации.
Как вариант, как и в реальной жизни можно было создавать класс Statistic и Warrior
одновременно, и в Statistic класть нужные данные под id нужного Warrior.
Печатать статистику так же по id требуемого воина, возможно так же проверяя
есть ли у запрашивающего права на это, т.к. мы могли бы работать с коллекцией классов Statistic.


**4 Класс хранит данные которые загоняются в него, во множестве разных мест в программе.**

Если мы говорим о неком объекте билдере, который наполняется постепенно, передаваясь через разные методы, например через цепочку а(), б(), c(),
то, например, если эту цепочку нарушат при изменении кода и попробуют выполнить build() получив объект из метода а(), то есть шанс ошибки. Например, если в ConnectionBuilder url например на арто, который какими-то из них не обладает
или password передавался только в шаге 6(). Тут можно говорить о минусе самого паттерна билдер. Следует выполнить рефакторинг, разделив объекты, если уж данные для них действиельно попадают в разных частях программы,
bDTO и уже в методе с() создавать resultobject, предусмотрев, что бы у него был конструктор,
в который можно передать только все требуемые параметры и нельзя создать объект,
(рассчитывая на их заполнение через set'еры). Таким образом, в каждом месте программы
будем иметь дело с консистентными объектами.

**5 Класс зависит от деталей реализации других классов.**

В слое сервиса завязываемся на проверку ошибки от конкретного вендора БД. Если вендор меняется, драйверы достаточно поменять, код репозитория под сервисом можно не менять, но потребуется изменять код в сервисе который обрабатывает исключение выбрасываемое репозиторием.


**6 Приведение типов вниз по иерархихи (Родительские классы приводятся к дочерним).**

Когда оперируем на уровне общения между частями приложения перебрасывая
объекты, как представителей родителя,
не вдаваясь в реализацию,
а в конкретных местах программы проверям
каким именно потомком является данный класс и передаем его на обработку в часть программы которая обрабатывает объекты данного класса, соответственно предварительно кастанув тип объекта родительского класса
до потомка.

Этот пример использования считаю положительным.

Плохим будет пример, когда потомок позволяет свое создание с некоторыми
не заполненными полями
например Аnimal с полем name
А его потомок Lion с доп полем speed
Если изначально объект класса Animal кастануть до Lion, To speed y него будет равен null.

**7 Когда создается класс наследник для некоторого класса, приходится создавать наследников и для некоторых других классов.**

У нас есть объект и обработчик данного объекта,
который завязан строго на его интерфейс Когда интерфейс мы решаем расширить новыми методами,
то в наследнике что бы использовать новыем методы/поля в обработчике, нам следует либо изменить обработчик, либо отнаследоваться от него
но тогда придется полностью переопределять сам метод обработки
Мне кажется здесь пример вернее будт, когда мы перееопределяем сущность наверху, которая как поля имеет в себе другие сущности И в этом наследовании, придется перееопределять и сущности уровнем ниже, если они бавязаны на проверку того, в каком объекте создается но тогда это нарушало бы всю идею того, что нижний слой ничего не знают о верхних слоях.
То есть оба случая показывают плохое проектирование.


**8 Дочерние классы не используют поля и методы родительских классов, или переопределяют родительские методы.**

Хороший случай:  
Переопределение equals() или tostring()

Плохой случай:  
В родителе никуда не годная реализация метода. Либо требуется подумать, стоило ли вообще в родителя выносить данный метод, если его приходится повсюду переопределять Возможно ошибка в построении иерархии.


_Уровень приложения_  

**1 Одна модификация требует внесения изменений в несколько классов.**  
Когда пренебрегают правилом использования интерфейсов, вместо завязки на конкретную реализацию.  
В целом сильная связанность.  
В частности пункты 7 и 5 из прошлого списка.

**2 Использование сложных паттернов проектирования там, где можно использовать более простой и незамысловатый дизайн.**

а) Не совсем паттерны, но в целом использование замороченной структуры функциональных интерфейсов, реализации которых вложены друг в друга, для операции чтения, там где можно было обойтись без них.

Как минимум стоило зарефакторить не вкладывая анонимные реализации, а наименовав каждую из них.  

б) Конкретно паттерны могли появиться там где не надо из-за того, что предполагалось что в будущем все станет сложнее, из-за внедрения новых.  

в) Разработчик только познакомившись с паттернами решил прикрепить их куда-то в свой проект :).  
