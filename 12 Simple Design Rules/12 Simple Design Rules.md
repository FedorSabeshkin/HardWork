# Правила простого дизайна

## І. Интерфейс спроектирован так, что невозможно совершить ошибку при работе с ним.

1.
В основном ошибки требующие исправления по инструкции, являются инфраструктурными,
нежели непосредственно связаными с классами основного продукта.
Тут можно подумать об _infrastructure-as-code_,
что бы все настройки требующие
инструкций и обработки кейсов вручную,
вынести в виртуалку и выдавать
НОВЫМ программистам для работы уже копию
этой виртуалки со всем настроенным.
Это действительно могло бы решить
большинство проблем описанных в документе FAQ для разработчика.

2.
 _До_  

Процесс переключения окон сделан, как метод,
который принимает id окна на закрытие и id на открытие.
Создавать новые переходы достаточно просто,
но при обработке ошибок натыкаемся на проблемы вроде того,
что в нетипичной ситуации:
Паралельно с работой на экране Б, завершился процесс
обновления справочников, о чем выдалось уведомление (экран в), с которого по нажатию "Ок"
перешли на главный (экран А) приложения,
а не вернулись к экрану Б,
или еще хуже, и перешли на главный экран А, но какие-то элементы перекрыты все еще
элементами с экрана Б, т.к. его видимость не была отключена.

_После_  

Закладывать более сложную структуру переключения экранов,
так что бы можно было переходить только в определенное множество
при этом не допускать ошибочных.
состояний,
В выше приведенном примере с экранами это можно было бы сделать как
два PowerSet.
Множество А состоит из одного элемента - экран который хотим показать
Множество Б из всех ранее открытых экранов.  

а) при переключении экранов вычисляем перечисление множеств и оставляем открытым только его,
все остальные закрываем.

б) Добавляем использованный A' в множество Б.

## II. Отказаться от дефолтных конструкторов без параметров, и передавать конструктору обязательные аргументы
3.
 _До_  
Класс Reader, которому файл для чтение передается через сеттер.
То есть метод read() можно вызвать до того, как файл будет положен в Reader, и получим NPE.

_После_  
Добавить передачу файла в конструктор класса Reader и сделаьть недоступным конструктор без аргументов (в java произойдет автоматически).

4.

_До_

Класс Game внутри которого создаю игроков и т.д.

_После_

Класс Game принимает игроков как входные параметры
Но как мне инициализировать этих игроков,
если захочу использовать Spring?
Сейчас инициализирую их в Game, при считывании данных с консолли.
