## Ревью

Есть общий, достаточно простой паттерн при проектировании логики это разбиение ее на часть инициализации и финализации.

Эта конструкция в языках программирования так же может быть упрощена не только синтаксически, но и на смысловом уровне, например, явным делая только процесс иницилизации,
а финализацию вызывать автоматически, предварительно подготовив ее реализацию.

### Примеры

*Не из конкретного кода.*

1. Требуется выделить некоторые паттерны в конкретной реализации.
Например при создании веб сервиса,
то, что создаем репозиторий,
с реализацией CRUD под конкретный объект мапящийся на некоторую таблицу, B Java мы можем заменить интерфейсом расширяющим стандартный интерфейс для CRUD с JРА. В результате методы будут сгенерированы автоматически, из одной строки кода -50 строк.
Минусы тут как и в других подобных случаях в меньшем контроле над тем, какие запросы сгенерятся, но если придерживаться некоторой достаточно простой архитектуы, зная ограничения генерируемой реализации, вполне можно применять данный метод.

2. Аналогично с REST Controller, или даже @RestData, когда пометив класс аннотацией, автоматически сгенерируется для него контроллер и репозиторий.
Да, как и то что подобный функционал по открытию файла был впервые реализован в Lisp в 80х через макрос, который затем упрощает код, так и аннотации помогают нам это делать.

3. Интересно, что на функционал закрытия/открытия мы можем завязываться не только с файлом, 
но и например с такой сущностью, как аккаунт.
Мы открываем его, выполняем некоторые действия по работе 
(пусть даже в течении нескольких лет)
и закрываем в конце.
Но поддержание такого контекста требовало больших ресурсов, что в данном случае правильнее будет,
выполнить непосредственно по требованию, а не автоматически.
Хотя, такой кейс подойдет для коротких сессий, вроде анонимных чатов.

### Итог

По сути все это программирование высшего порядка, 
когда мы наш код передаем в уже существующую некоторую функцию, 
в обертке которой он будет исполняться.

