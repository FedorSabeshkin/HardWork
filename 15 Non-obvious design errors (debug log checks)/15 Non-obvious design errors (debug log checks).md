## Ревью
Проверки из методов оперирующих внутренними состояниями классов, стоит выносить в сами классы.  
От излишнего логирования ошибок и валидации во всех местах программы, может помочь сохранение самой этой валиадации, но вынесение ее на уровень конструкторов/фабрик объектов, которые не позволят создать объект в невалидном состоянии для ее прикладной логики.

### Примеры
1.
Ввод части тела для удара в терминале
*До*  
Можно вводить любые символы на любую длину. 
Далее строка сравнивается с одним из 4 значений: Head/Torso/Legs/Hands (без зависимости от регистра хотя бы).

_После_  
Разрешен ввод только значений от 1 до 4 цифрами и Ctrl+X для выхода, так же выхода из игры.

Сделать это можно пытаясь создать соответствующий выбор для нанесения удара. 
То есть по выходным данным просто в фабрике создавать экземпляр нужного типа.

Тогда сами эти проверки на валидность будут в этой фабрике.

Но сами экземпляры созданные этой фабрикой проверяю отдельно.
Будто просто лишний класс добавил, с другой стороны привязал валидацию к конкретной фабрике, то есть непосредственно "Поднял на уровень выше"

Либо у меня пока просто нет правильной абстракции, для переключателя, и его достаточно в том виде, в котором он есть.

2.  
Автозаполнение номера телефона

Я захожу на сайт, при заполнении формы браузер предлагает мне ввести те данные номера телефона, которые я обычно использую

_До_  
В поле на форме номер начинается с +7, но когда я выбираю заполнить форму ранее использованными данными, то браузер вставляет мой сохраненный номер полностью , но после +7.
То есть получаю +7 (*79) 99х - xx - xx или +7 (899) 9хх - хх - хх

Вместо этого надо 
_После_  
+7 (999) ххх - хх - хх без необходимости какого-либо ручного доп редактирования.

3. 
  
_До_  
В классе содержащем информацию о здоровье бойца, 
был мето .getCurrentHealth(), который в том числе 
использовал для того, что бы проверить,
может ли боец продолжать бой.
Это лишний раз доставало внутренне состояние объекта здоровья
и проверка осуществлялась за пределами класса.

```java
  /**
   * Проверка на то, что у боцов остались очки жизней для продолжения.
   */
  public boolean isContinue(Warrior w_1,
                            Warrior w_2) {
    return w_1.getHealth()
              .getCurrentHealth() > 0
        && w_2.getHealth()
              .getCurrentHealth() > 0;
  }
```

_После_  
добавлен метод isContinue в класс Warrior,
что бы в приниипе не требовалось доставать его
состояние здоровья, а из состояниея здоровья,
его конкретное значение.

В класс Health добавлен метод isExist(),
который сравнивает внутренее числовое представление
здоровья и говорит, осталось ли оно еще.

```java
  /**
   * Проверка на то, что у боцов остались очки жизней для продолжения.
   */
  public boolean isContinue(Warrior w_1,
                            Warrior w_2) {
    return w_1.isContinue()
        && w_2.isContinue();
  }


class Warrior{

	public boolean isContinue(){
		return health.isExist();
	}

}

class Health{
	
	public boolean isExist(){
		return currentHealth > 0;
	}
}
```
4.  

Аналогично случаю (1)
_До_  
```java
	String in = scanner.nextLine().toUpperCase();
    switch (in) {
      case "Б": {
        Battle battle = new Battle();
        BattleResult battleResult = battle.startWithNpc(warrior,
                                                        statistic,
                                                        scanner);
        warrior = battleResult.getWarrior()
                              .treatToDefaultSize();
        statistic = battleResult.getStatistic();
        break;
      }
      case "М": {
        warrior = shop.goToShop(warrior, scanner);
        break;
      }
      case "Л": {
        personalRoom.inRoom(warrior, scanner);
        break;
      }
      case "С": {
        statistic.show();
        break;
      }
      case "Х":
        System.exit(0);
      default: {
        Formatter.log("Вы ввели неверную команду, попробуйте еще раз");
        selectAction(scanner);
      }
  }
```


_После_  
```java
	String in = scanner.nextLine().toUpperCase();
	ActionFabric.getActionByName(in);
	  
// внутренний класс
/**
* Пока делаю эти классы внутренними, что бы не передавать слишком много аргументов,
которые могу понадобится для работы их методов.
**/
class ActionFabric{

  public void getActionByName(String name){
      case "Б": {
         return new BattleAction();
		 
      }
      case "М": {
        return new ShopAction();
      }
      case "Л": {
        return new PersonalRoomAction();
      }
      case "С": {
        return new StatisticAction();
      }
      case "Х":
        return new ExitAction();
      default: {
        Formatter.log("Вы ввели неверную команду, попробуйте еще раз");
        selectAction(scanner);
      }
  }

}  
/**
* Класс с действием битвы.
**/
class BattleAction impements Action{

	
	public BattleAction(){
          Battle battle = new Battle();
          BattleResult battleResult = battle.startWithNpc(warrior,
                                                        statistic,
                                                        scanner);
          warrior = battleResult.getWarrior()
                              .treatToDefaultSize();
          statistic = battleResult.getStatistic();
	}
}

/**
* Класс с действием битвы.
**/
class ShopAction impements Action{

	
	public ShopAction(){
		warrior = shop.goToShop(warrior, scanner);
	}
}

// и так дале для PersonalRoomAction, StatisticAction, ExitAction 
```




5.
К сожалению в основном классе Scanner 
нет функционала, который бы позволял ввод только определенных символом,
можно было бы самостоятельно реализовать такой функционал позволяя
вводить только символы, которые отразятся
в валидные значения, а от иных отчищать поле, 
но лучше подключить уже готовую библиотеку.

Из терминала в любом случае приходится считывать данные из поля,
только после окончания ввода


## Итог

Если кажется что кол проверки не изменился, но вынесен он на другой уровень, как в примере (1), 
то это вполне себе подход к правильному проектированию. 
Либо оставить все как есть и рассуждать, что разработчики опытны и для быстрой разработки текущая реализация пойдет, но для долгосрочной работы над проектом, 
что является стратегической целью - надо выносить.
