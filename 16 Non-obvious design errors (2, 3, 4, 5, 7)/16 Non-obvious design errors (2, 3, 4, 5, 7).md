### Главные идеи

Надо хорошо продумывать границы разрабатываемой системы, т.к. с нею жить вполне вероятно десятки лет,

и в этих границах будет описано взаимодействие с системой

Надо рефакторить не код,
а весь дизайн системы
Здесь полезна "объектная гимнастика",
т.к.
она требованием в 2 поля на класс, влияет на то, как программистТ
будет декомпозировать
Рефакторинг на уровне кода мелочь

Если требуется только часть методов из некоторого класса библиотеки другого проекта,
то следует выполнить рефакторинг
в классе этой библиотеки, распилив его на 2, например,
и уже только 1 из них импортировать в свой проект.
Если доступ до кода есть,
то нормально переделывать его, если так будет лучше для системы их этих
проектов вцелом. 

1. В нескольких задачах, которые выполняют различные разработчики одновременно, 
требуется различный рефакторинг класса А.  
Разработчикам стоит узнать,
кто еще работает с этим же классом в текущем спринте и вероятно завести отдельную задачу на рефакоринг, 
что бы учесть все требования и можно было выполнить решение на уровне дизайна системы.

2. Рефакторинг нескольких строк не упрощает весь дизайн в целом.   
Если в классе или ряде классов есть единый подход к оформлению методов, при создании новых методов в этом
классе, надо придерживаться такого же принципа, чем один из методов начнет выбиваться из общей идеи,
конечно если эта идея есть.

3. Важно думать что делается, а уже затем погражаться в "как".  
Поэтому при онбординге важно показать общие схемы взаимодействия компонентов,
после чего программист уже по внешним интерфейсам дополняемого им модуля будет представлять,
куда обработанные им данные пойдут дальше. 
Но общее представление о всей системе здесь полезно, если имеются некоторые сайд 
эффекты, от обработки данных в контуре А, которые могут возникнуть 
в контуре Б, если не введены соответсвующие ограничения в системе. 

4. Тесты надо писать так, что бы тестировалась спецификация модуля,
а не его конкретная реализация. 

### Примеры рефакторинга на уровне дизайна

#### I.  
_До_  
MVC приложение.
В контроллер поступает фильтр с UI, который конвертируется в фильтры
для нескольких backend систем, из которых будут отображены данные.
Списки объектов из бэкенд систем требуется сконвертировать 
в объекты, которые подаем на view для фронта.
Все это написано в одном классе контроллера и для тестирования
приходится мокать бекенды, и фактически делать слабый регресс тест,
что хотя бы обратились именно к тем системам к которым ожидалось,
либо делая тест более хрупким, писать моки специфицированные под конкретные
значения фильтра, которые ожидаем получить при внутренней работе
метода, по описанной выше схеме.

_После_  
В конртроллере три задачи выделяем на несколько классов:
1. Сервис обращения к backend сервисам - с фильтра фронта определяется к каким бэкенд сервисам потребуется обращение, 
в нем же используется UiFilterToBackand_X_Converter.  
2. UiFilterToBackand_X_Converter - конвертирует фильтр с фронтенда в фильтр для конкретного backend сервиса  
3. BackendToUiItemConverter - методы для транформации,
которые принимают UiItemBuilder и различные типы объектов из Backend,
добавляя данные из них в итоговый объект.   
Класс содержит в себе как поля Backend_X_ToUiItemConverter конверторы сущностей из конкретных backend сервисов.  

Таким образом каждый из классов мы можем тестировать независимо и достаточно просто.  
Мокировать можно только для сервиса обращения к backend системам.

Такми разделением явно - через интерфейсы - заданы границы каждого решения и самих подзадач.



#### II. Группировка всех IO в одном месте и отделение их от прикладной логики.  

Например есть класическая связка:
Контроллер вызывает метод сервиса
В сервисе происходит предварительная обработка аргументов, и затем происходит обращение к репозиторию
Данные из репозитория проходят обработку перед возвратом клиент (в целом как и в первом кейсе).

Но тут можно выполнить следующий рефакторинг:


1. На эндпоинт выделяется отдельный файл контроллера. 
2. Из общего сервиса выделяются в новый сервис методы, требуемые конкретно в этом контроллере. 
3. Всю работу с БД выносится из сервиса на уровень контроллера. 
Таким образом сервис выполняет только обработку прямо переданных в качестве аргументом данных. 
Для тестирования методов сервиса можем просто через конструктор сформировать объект машины, предприятия, даты и т.п.. 
БД подключается только для тестирования контроллера и самого репозитория. Моки не используются. Понадобятся,
только если действительно нет возможности обращаться к backend системе, например, 
если она еще не реализована. 

Границы заданы явно - через интерфейсы.

#### III. Как и в изначальной теории.  
Что бы не делать импорт разрушающий
импортом целого сервиса А, который разработан под конкретную задачу,
всю логику деления классов, в класс Б в котором понадобилась часть утилитных методов, 
находящихся в этом сервисе, который стал импортировать и в изначальном
вынес из него методы в класс XUtil,
сервисе А, и в новом классе Б.

Здесь также явно заданы границы.


### Написание тестов как use cases
Как пример use case тестов можно привести UI тесты, когда описываем интеграционного взаимодействие. 
В целом все IT тесты, где понятными названиями и непосредственными эмуляторами пользователей можем понятно выражать взаимодействие системы. 

Если говорим о взаимодействие через REST API, то кроме правильного нейминга объектов, методов и пояснений для теста (`@DisplayName("...")` в Java), сложно что-то придумать. 
Конечно, можно ещё тестировать только часть функционала, например  "Получение данных о Х". Где Х - сущность для фронтенда, а в самом тесте происходит обращение к сервису, который агрегирует данные с нескольких бэккенд систем, которые на него были поданы. То есть напоминаем дополнительно о то в рамках решения какой общей задачи этот класс существует. 
Но это все равно не совсем то, что требовалось бы. 
Все таки для use cases требуются IT.
