### Идея
Всего не предусмотришь, но по методологии thin-to-thick,
стоит переодически перегрупировывать получившиеся модули так,
что бы с ними было удобнее работать, например не тащить лишний 
функционал при импорте.
Так и потому, что это делает текущий дизайн системы для решения задачи 
прозрачным для новых разработчиков.

Под нелокальным рефакторингом здесь подразумеваю, когда требуется поменять,
не несколько строк кода, а дизайн системы, архитектуру, разбиение по модулям и классам.
Но не подразумеваю пока полное переписывание решения, что бы достигать этого рефаторинга
за разумное время. 
Как признак того, что его выполнить можно, использую ту светлую мысль: для любого 
решения в мейнстриме возможен дизайн, который сделает его достаточно понятным.

### Примеры

1.  
а) При первой реализации, в корне проекта пакеты с несколькими api лежали на том же уровне, что
и приложения,
использующие эти API

б) На второй итерации был выделен отдельный пакет для API,
отдельный для приложений

в) На третьей итерации приложения были перегруперованы
из пакетов по тому, с какими сущностями из API они преимущественно работали,
в более высокое разделение, работают они в внешними сервисами или внутренними.  
Все эти перегруппировки служили тому, чтобы наиболее близко отражать действующую идею системы.


2.  
Наше приложение было cloud, но из-за изменения возможностей его распространения, стало on-premise.  
а) Если раньше всю работу с правами на обращение к облачному сервису решал провайдер облака,
то теперь потребовалось обеспечить эту защиту самостоятельно, продумав что использовать в качестве энтропии.  
б) Как обезопасить (обфускация) исходный код от тривиальной декомпиляции, т.к. он будет находиться не на наших серверах,
а значит лицензию могут попытаться сделать бесрочной. 

Так же нелокальный рефакторинг естественным образом возникнет,
если начнем следовать правилу из Object Calisthenics, 
о наличии не более чем двух полей в классе. 
