## Идея

Дается взгляд с нового измерения о том, что является зависимостью, через ряд наводящих вопросов, на которые надо ответить.

## Примеры

### 1. Зависимость от фреймворка.

Если round-robin планировщик запускает несколько задач, то он не зависит от каждой из них, т.к. зависит только от некоторого интерфейса взаимодействия, без завязки на реализацию.  
Паттерн команда.  
С другой стороны, конкретно round-robin,
ждет когда задача даст сигнал о том, что она завершена.
Но это скорее запуск задач зависит от того, запустит ли их гоund-robin.

### 2. Зависимость при обмене данными, который один модуль посылает, а другой считывает.

Пример:

а) один записывает данные в файл, а второй должен их считать.

б) один посылает запрос через АРТ, а второй его считывает.

Тут зависит ли А (отправитель) от Б (получатель) или наоборот будет зависеть от кейса.
Если А является с точки зрения БС (бизнес сценария)
обслуживающем модулем, которому надо, что бы его данные читали новостной сайт, а Б живым читателем, например
то можем говорить, что А больше зависит от Б.

Пример: За крайние 30 лет многим печатным газетам (АРІ 1.0), пришлось завести свой сайт и страницы в соц. сетях (АРІ 2.0),
т.к. многие из их клиентов сменили API 1.0(покупка и чтение физических газет)
и перешли на АРІ 2.0 (чтение новостей в интернете).

С другой стороны, если клиент живет в маленьком городе, куда не доходит уменьшенный тираж печатного издания,
которое он привык читать.

То есть А с API 1.0 перешло на АРІ 2.0, то ему может потребоваться купить устройство для выхода в интернет, даже если до этого он обходился без него, и начать использовать АРІ 2.0.
В общем, кому приоритетней выполнять данную задачу, тот под существующие API и подстраивается,
т.к. она буквально от него "зависит" :).   
Это могут быть и датчики со старым и неудобным АРІ, которые приходится поддердживать в новой системе, иначе есть риск "перегрева", например.  
И некоторые социальные отношения, когда работнику не хочется приходить на работу в 9 утра, но надо :).    
Надо отметить, что во всех этих местах имеет место конкуренция
или ее отсутствие (с поддержкой старых датчиков, т.к. иных возможности поставить нет) и задается здесь зависимость скорее на уровне бизнес сценария.

### 3. Зависимость зависимости

А независит от Б. Могут ли измененеия в Б повлиять на А?  

А если из Б изменить глобальную переменную используемую в А?  

Сначала хотел возмутиться, как же такое возможно, и где изоляция уровней программы, 
что бы нижние уровни не знали о верхних, но в случае с системными переменными, 
которые являются уже глобальными для всех исполняемых в системе программ, такое действительно может произойти.
Получается, что А, все таки может зависеть от изменений в Е.

### 4. Зависимость краша

Более экстремальный вариант третьего. Фактически следствием из (3), но с учетом не только переменных среды, но и других факторов, может получиться, что все зависит ото всего, что близко к определению из задачи (5)

### 5. Зависимость перебрасывания

А не сломается, при отказе Б, и перейдет к с, но верно ли что А, не зависит от Б?  

Здесь поднимается интересный вопрос. С одной стороны А может работать без Б, но с другой, если откажет и Б, и С, то А перестанет работать, чего бы не произошло если бы Б работало.
То есть А зависит от Б.
Думаю, что у этой задачи есть какая-то традиционная греческая формулировка, но не могу ее вспомнить.

### 6. Зависимость инверсии.

В DI предполагается, что то, что при зависимости А от Б, Мы получаем большую гибкость при передаче А динамически ссылки на Б, вместо статического связывания и таким образом, снижается зависимость А от Б, но фактически, при отказе Б, откажет и А.

DI нам все равно полезен, т.к. в случае отказа, нам достаточно поменять реализацию Б, и сам файл конфигурации,
в котором создаем ссылку на конкретную реализацию Б
вместо внесений изменений в А,
которые могут создать доп ошибку, которую придется искать уже в А, а не в файле конфигурации или Б.
Как и в других примерах,
здесь у нас есть в явном виде зависимость от интерфейса,
но не от реализации.

### 7. Зацикливание зависимостей.

Если А зависит от А, то попробую рассмотреть это, как А, зависит от Б,
а Б, зависит от А.  

Такие случаи знакомы и если не слишком запутаны,
то допустимы для рефакторинга,
когда выделяем общее от чего зависим в класс Д 1,
или даже Д_1 и Д_2, так что бы А зависело от Д_1, Б зависело от Д_2,
а А зависело от Б, НО, Б уже не зависит от А.
Возможно Д_1, будет несколько дублироваться с Д_2.
Если выносить это общее в еще один класс,
то придем к транзитивной зависимости...
Д_1 и Д_2 зависят от С_3, а значит А и Б зависят от С_3.
Но в целом, А зависит от А,
на первый взгляд означает потенциальную возможность такого рефакторинга, но не уверен, что это доказано математически и действительно так.

### 8. Зависисть стандартных библиотек от вызывающего их кода.  

С одной стороны, элеметы для хэш-таблиыцы, это меньшая часть строительные блоки от которых она может зависеть, пока "строит здание" этой хэш таблицы.
С другой стороны, когда хэш-таблица используется в нашем проекте, который заметно сложнее, то уже хэш-таблица для нас всего лишь вспомогательный кирпичик, который нам помогает, а точнее даже работник, например "плиточник", от которого зависит наша программа. У него есть некоторый интерфейс и фактически, то, что хэш-таблица, не будет выполнять нашу работу наша вина, если мы будем подавать ей объекты с реализациями hashCode и equals,
которые не позволяют различать объекты.

### 9. N-version programming  

Реализации независимы, если мы изменям только меньшинство к из л, где k < n/2. Получается, что агрегирующая их программа, которая и выбирает ветку в зависимости от "голосования", зависима от каждой из них, какое поведение получится в результате. Что вполне соответсвует тому классическому определению, что крупное зависит от более мелкого из чего состоит.


### Итог
Выглядит так, что что-угодно в мире зависит ото всего :).  
В ПО мы можем лишь стараться снизить эту зависимость, но полностью независимым модули не сделать. В том или ином виде зависимость будет, пусть даже от интерфейса/протокола.
