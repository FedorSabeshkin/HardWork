## Идея

Зависимость появляется, когда мы говорим в спецификации, что если в случае ошибки в Б, упадет А, то это зависимость.

Если в спецификации этого нет, то зависимостью мы это не считаем.

Это подобно тому, что в Jаvа не требуется обрабатывать RuntimeException, т.к. он всегда может возникнуть, и наша программа может завалиться. С другой стороны, если мы пишем файл в конкретном контексте, например на ТСД и знаем, что там может закончиться место на диске, то в спецификации будет прописано, что нам надо обрабатывать RuntimeException с окончанием памяти при сканировании товара или загрузке его каталога.

В то время как в спецификации будильника, врядли требует выноса в спецификацию требования об обработке заполнения памяти при создании будильника на очередное время (6:00, 6:15, 6:30, ...), хотя для супер надежности это и возможно сделать, но это удорожит стоимость разработки программы и в данном случае вряд ли окупится такой уровень надежности.

## Примеры
### 1. Зависимость от фреймворка
Проект зависит от веб фрэймворка.

а. Свойство разрешения на эксплуацию программы.

б. На пространстве версий веб фрэймворка, в разрезе отсутсвия/наличия в них известных уязвимостей.

### 2. Расширенность формата

Средство автоматизации контролирующие добавление информации завивисит от того, в каком формате (в контексте стилистического оформления) описывают добавления. Решить временно можно в виде "суперспецификации", попросив всех записывать верно, либо будут санкции.

Либо более сильно, через другое средство автоматизации, например, введя регулярку на то, в каком формате надо производить оформление.

### 3. Зависимость зависимости

А независит от Б. Могут ли измененеия в Б повлиять на А?

А если из Б изменить глобальную переменную используемую в А?

По крайнему вопросу можем сказать, что в конкретной вычислительной модели использующей транзитивные зависимости, свойство А отвечающее за число создаваемых потоков, зависит от поведения Б, на множестве изменений им глобальной переменной используемой А(конкретно дефолтного числа создаваемых потоков).

От изменений на другом множестве переменных, вызванных поведением Б, модуль А не зависит.

### 4. Зависимость краша
Мы пишем в файл в конкретном контексте, например на ТСД и знаем, что там может закончиться место на диске, то в спецификации будет прописано, что нам надо обрабатывать RuntimeException с окончанием памяти при сканировании товара или загрузке его каталога.

В требованиях к системе, мы прописываем "Наличие не менее п мегабайт свободного места при начале работы."

### 5. Зависимость перебрасывания
Если для работы А пробуем использовать Б, который недоступен и в этом случае используем С, то зависим ли мы от Б?

Когда С всегда доступен нет, независим, но так не бывает.

Наше свойство "быстрое обслуживание клиентов", в конкретной вычислительной модели обмена платежными данными по сети, зависит от работоспособности Б (выполняющего работу быстро), на пространстве изменений доступен/недоступен.

Свойство "совершение платежа" (при терпеливом клиенте) не зависит от Б, т.к. в случае его недоступности, платеж будет выполнен через С. Тут мы уже фактически зависим от С, т.к. на его пространстве изменений доступен/недоступен наше возможность совершения платежа может измениться. Зависит ли это косвенно от Б. Думаю что фактически нет. Это вроде как младший брат. Ему могут дать какое-то задание, но с учетом что присматривать будет старший и при необходимости его выполнит. Если же младший уйдет играть, а старший задание не выполнит, то вся ответственность ляжет на старшего. "Ты же ответсвенный".

### 6. Зависимость инверсии

У нас DI, но тест не запускается и висит без каких либо ошибок. Можно решить, что проблема в IDE, но на самом деле, при создании бина, который является клиентом к внешней системе, при неуспешном подключении к ней, не выбрасывается исключение, а так и зависаем в состоянии ожидания поднятия системы, без какого-либо сообщения в логах, например "Не удалось подключиться. Поднемите в docker system_name".

DI, но были завязаны на такие вещи в окружении и не оповестили о них вовремя.

### 7. Зацикливание зависимостей

При А зависит от Б и Б зависит от А, надо провести рефакторинг позволяющий выделитит зависымый код в модулиь Д 1, или даже Д_1 и Д 2, так что бы А зависело от Д 1, Б зависело от Д 2, а А зависело от Б, НО, Б уже не зависит от А.

Возможно Д_1, будет несколько дублироваться с Д_2.

Если выносить это общее в еще один класс, то придем к транзитивной зависимости....

Д_1 и Д_2 зависят от С_3, а значит А и Б зависят от С_3.

### 8. Зависисть стандартных библиотек от вызывающего их кода

Если в случае с HashTable она даже при условно не совсем верном вызове продолжает реализовывать свой контракт.

То и свои классы надо делать такими, что бы гарантировать верную работу при их использовании.

### 9. Зависимость большинства

Влитие МР, требующего 3 апрувов от любых из разработчиков, не зависит от 1 конкретного, но зависит от множества из З (А,В,С) любых разрабочтиков.

## Вывод
**Самое главное для меня понимание принципа Single Responsibility из SOLID.**

Все никак не мог взять в толк сколько нибудь комплексный пример где бы это реализовывалось, ведь после разделения функционала User например на UserRepository, UserEmailValidator, UserEmailSender и DTO User, нам все равно потребуется создание UserService, в котором через *has-а* будем использовать все эти классы, то есть фактически UserService уже ответственнен и за сохранение/удаление пользователей, и за отправку email и за валидацию данных еmail, то есть весь принцип игнорируется в типичном же паттерне.

Но фактически, когда мы говорим о SR, то вносим дополнительное ограничения на наши рассуждения "в конкретном классе, не погружаемся до ответвенностей используемых других классов".

То есть UserService ответственен только за вызов нужных методов конкретного сервиса и выполняет роль фасада.

С друго стороны, если метод UserService.sendEmail подразумевает такую реализацию в которой используются несколько других сервисов, то верно ли, что он отвечает за отправку сообщений И за предоставление фасада для обращений к другим сервисам. И само предоставление фасада к

разношерстным сервисам не нарушает SR? Если предоставляем доступ к этим методам без изменений, и по сути в разных контекстах нарушает. Если контекст только один - *"Реализация методов на уровне бизнес требований, а не более низком"*, то в чем то сохраняет. В свою очередь у Repository будет *"Реализация методов на более низком уровне записи в БД"* 

Другое дело, насколько сервисов мы фактически должны разбивать данный сервис? Ведь бизнес требования могут быть из разных областей. Это сохранение информации о пользователе и отправка пользователям email. Считаем, что это лежит в одной плоскости бизнес требований?

Да и вообще, о любом классе можем сказать, что его SR "корректная работа программы в соответсвии с БЛ" и это обоснует наличие в нем совершенно разношерстных методов, если уровнем выше все они используются корректно.

