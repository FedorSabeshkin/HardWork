## Размышления

Теоретически легко допустить ошибку не вызвав определенный метод при обработке данных и это поведение хорошо бы задать в StateMachine, но на практике, код копируется по большей части из одного класса в другой эта часть по вызову методов практически не меняется.
Поэтому редки ошибки. + есть тесты которые это проверяют, так же по шаблону, то есть выполняют функции ТОР сбоку.

Возвращаясь к теста, все то что мы пишем через Mockito.verify(...), это проверка на переход к требуемым состояним (что точно был вызван соответствующий метод, а в идеале с конкретными аргументами).
В основном мы выполняем verify, для методов чтения/записи.

Как и с DAO, тут для большей гибкости не очень удобно выполнять это слишком жестко каким-то внешним каркасом, как ORM, а все таки писать напрямую в императивном стиле, когда для каждой задачи записиываем последовательность вызовов методов вручную.

Выделение интерфейса в который будем передавать функции не убирает проблему в том, что можно ошибиться в вызовах. Зато может обеспечить проверку того, что переданны все сервисы общение с которыми требуется по постановке, что можно упустить при копировании кода на
создание новых схожих классов.

**Возможное решение:** Для реализации только правильныз последовательностей вызовов - каждый следующий метод_(n+1) принимает в аргументе "отработанный" объект, который становится таковым после вызова метода_(n) на себе. 

*Примечание*  
- В ФП мы могли бы быть уверенными в том, что корректно выполнен переход в конкретное состояние используя Sum Types.

## Примеры
1. В целом, это подход похож на аутентификацию, где мы должны выполнить определенную последовательность действий - сначала передали пароль в открытом виде, получили его в зашифрованном, теперь передаем этот зашифрованный пароль в метод аутентификации, в который в случае передачи пароля в открытом виде будет выдана ошибка, либо в принципе в его сигнатуре нельзя передать просто char[], а только EncryptedPassword, который создается только методом шифрования и не имеет публичного конструктора. Затем получаем токен, с которым уже можем обращаться к АРІ, которое тоже принимает конкретный тип Token, который не имеет публичного конструктора и может быть получен только из метода аутентификации. Таким образом последовательность вызовов метода становится необходимостью за счет ограничений в интерфейсах методов и отсутсвию публичных конструкторов для требуемых для них аргументов.
- До
  
```java
// везде применяется массив char[], который фактически можно запросто создать где угодно
String login =

char[] password =

char[] encrypted Password = encryptor.encryptPassword(password);

char[] token = authService.auth(login, encrypted Password);

List<Comment> commenst = commentApi.getComments(token, postld);
```

- После

```java
package ru.sun.project.service


String login = ...

char[] password =

Encrypted Password encryptedPassword = encryptor.encryptPassword(password);

Token token = authService.auth(login, encryptedPassword);

List<Comment> commenst = commentApi.getComments(token, postId);



// Классы
package ru.sun.project.comment

interface CommentApi {

  List<Comment getComments(Token token, Postld postId);
}

package ru.sun.project.auth

interface AuthService{

  Token auth(login, encryptedPassword)

}

package ru.sun.project.auth

public final class Token {

  protected Token(){
  }

}

package ru.sun.project.encryptor

interface Encryptor{

  EncryptedPassword encryptPassword(char[] password);

}

package ru.sun.project.encryptor
/**
* final, что бы исключить создание наследников, в которых переопределят конструктор.
**/
public final class EncryptedPassword {

  // protected, что бы экземпляр можно было создать только в конкретном пакете, например в пакете еспryptor в класс Encryptor. В другом пакете создать класс будет нельзя, но можно будет вызвать метод Encryptor. encryptPassword(...), и получить экземпляр Encrypted Password, т.к. сам класс public.
  protected EncryptedPassword (){
  }

}
```


2. В целом мы можем переписать некоторые методы от использования в одном классе на использование в нескольких, рефакторя по SRP, но это не будет гарантировать нам вызов этих методов в определенной последовательности.
   
- До

  
```java
// Метод перевода сущности в статус 3.
public void toStatus3 (Entity entity) {
  if (entity.getStatus() == STATUS_3) {
    throw RuntimeException("Сущность уже находиьтся в статусе 3");
  }
}

Entity {
  // Статус сущности
  Status status;
}
```

- После

  
```java
// Перегрузки метода для перевода в статус 3 есть только принимающие сущность
// в статусе 1 и 2,
// но НЕТ принимающих с статусе 3
public void toStatus3 (EntityInl EntityInl) {

}

public void toStatus3 (EntityIn2 blockedWallet) {

}

// Сущность для отображения в первом статусе
EntityIn1 {
}

// Сущность для отображения в втором статусе
EntityIn2 {
}

// Сущность для отображения в третьем статусе
EntityIn3 {
}
```


3.
   - До
  
  
```java
Book {

  open();

  read();

  close();

}
```

   - После

     
```java
ClosedBook {

  open();

}
OpenedBook {

  read();

  close ();

}
```

## Итог

\+ Интересный подход.  

\- Почитав хабр, натолкнулся на человека, что сначала увидел хорошую возможность для реализации StateMackine в своей программе, создал ее, а через некоторое время потратил усилия на переписывание всего на обычный императивный код.
В некоторых случаях я тоже задумаваюсь, не усложнит ли рефакторинг код излишне.
Удобный пример StateMachine так же найти не удалось. Правда попалась библиотека от Роберта Мартина, но примеры ее использования так же не выглядят упрощающими рассуждения.

\+ Примеры поклучились весьма интересными и упрощающими, как с аутентификацией. Надо изучать дальше.
