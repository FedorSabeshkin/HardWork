## Идея

**Многоуровневая архитектура - это фактически ациклический ориентированный граф.**

Общение от нижнего уровня к верхнему возможно только как асинхронное сообщение.

Нужно рассматривать это именно так, а не как то, что каждый уровень является комбинацией низлежащих уровней.

Не до конца понимаю абзац касаемый того, что интерфейсы более высоких слоев хранятся в более низких?   
Ведь общаться мы можем в данной архитектуре от более низких к более высоким только асинхронным сообщением.

Наверно, я сначала не праваильно понял, имеется в виду, что интерфейсы более низкого уровня находятся в более высоком. Тогда все логично.

Интерфейсы по работе с BIOS должны быть известны более высокому уровню ОС.

С другой стороны, если они находятся там, то уровню BIOS приходится подключать как зависимость модуль с этими интерфейсами, 
модуля более высокого слоя. есть зависимость на уровне сборки и разработки от модуля более высокого слоя.  

Когда же каждый уровень мы считаем полноценным, при том что уровень более высокий должен базироваться на реальных более низких.

При этом объявление и документация этой сущности более высого уровня находится в интерфейсе боллее низкого уровня.

Это позволяет нам задеплоить любые М идущих по порядку слоев независимо от деплоя более высоких слоев.

А вот более низкие мы можем создавать без необходимости как-то подкладывать более высокие.

### Строгая слоистая архитектура
**Строгая слоистая архитектура** - когда мы можем на определенном уровне В создавать только сущности уровня С или еще более низкого. Но не можем более высокого уровня А.
Сделать это в Java можно через ограничение видимости пакетами или модулями.

## Вывод

Модель с ациклическим направленным графом сильно упрощает рассуждение о программе и вроде как не убирает свойство синергии, которые мы можем непосредственно описать в узле, 
который соединен ребрами с низлежащими узлами, не обладающими каждый в отдельности свойством которым обладает верхний узел.

Примечание: архитектурная воронка - антипаттерн, при котором на уровне сервиса обращающегося к другому сервису и данные полученные от него не обрабатываем, а сразу возвращаем.

Обычно это допустимо, если процент таких запросов в сервисе 20% к 80% тех, которые производят обработку над полученными данными, 
прежде чем передать их выше. В ином случае, стоит задуматься о необходимости это проксирующего слоя и возможно в ряде случаев лезть из более высокого уровня напрямую в требуемый сервис, перед этим убрав проксирующий.

Конкретно моя система соответсвует НЕ строгим принципам МУРА.

Можно развернуть несколько сервисов без необходимости в развернутости остальных. На самом низком уровне в моем проекте находится ОС, потом БД, затем сервисы первого уровня, затем сервисы использующие эти сервисы.

Если рассматривать более полно, то будет еще и BIOS, но конкретно я им не занимаюсь и не взаимодействую в отличии от ОС.

