## Идея
***Раздутый код** - это про логику его работы. Объем тут решающую роль не играет. Можно сказать, что это "Размазанная логика"*.

Если работая с правилой СД(структурой данных) там достаточно посмотреть на нее, что бы понять, какие значения для нее корректны, и вызывая ее из разных мест программы сможем переводить ее в верное состояние, то с раздутым кодом проблема в том, что в зависимости от вызывающего контекста, СД может хранить совершенно разные доменные данные.

С одной стороны нормально, когда LinkedList может использоваться для хранения различных значений, но при этом он сохраняет корректное выполнение своего конктракта, о котором можно прочитать в единой точке.

А если же мы создаем СД, которое может иметь какие-то внутренние флаги, в зависимости от заполнения которых оно несет разный смысл, то эту СД как минимум, будет полезно разделить на несколько, каждый под свое состояние.

Что бы не искать и не анализировать все создания этого СД из разных мест кода и их контекст.
Но есть и другой вариант.
Проект уже написан и его надо принять, разумеется, в нем будет раздутость, но это не повод винить во всем прошлых разработчиков и то, что такой проект достался. Важно смотреть на проект не как на инструкции языка программирования, а как на поток данных, над которыми происходят транформации. Функции здесь лишь описания промежуточных транформаций.

## Примеры

**I.**

До

1. DТО в поле даты использует String. Там может быть строковое представление даты получаемое из json, а может быть пустая строка, если не смогли ее заполнить. В классе, который отвечает за печать этого DTO в таблицу, выполняется проверка на то, пустая ли строка, и в этом случае ставится заранее оговоренное дефолтное значение даты, уникальное для данного контекста.

Иначе дата парсится из строки в LocalDate.

После

2. В DTO дата хранится в поле типа LocalDate. В конструктор принимается информация из контекста о дефолтной дате, которая используется, если не была передана основная информация.
Контекст в работе с DTO используется таже, что и в классе принтера. До рефакторинга она так же была там доступна.
То что дата может быть не проставленна, вместо пустой строки передается черех использование Optional<>.

**II.**

До

1. Для изменения структуры БД в приложении на мобильном устройстве, при получении новой версии web-приложения информация о версии БД (х.у.) сохранялась внутри приложения в хранилище не связанном с основной БД (например сookie браузера). Если в загруженном приложении версия была выше той, что была ранее сохранена, то старая БД полностью удалялась и накатывались измененные скрипты с новой структурой. Разумеется не перекинутая из БД информация удалялась.

Таким образом версионирование БД было размазано по нескольким частям приложения, которые подразумевали ветвление.

После

2. Для изменения БД выбрана схема с версионированием скриптов. То есть как в flyway, в БД мы заводим специальную таблицу, в которой храним информацию о скриптах, которые уже накатывали и их хэши, с условием, что однажды созданный скрипт менять уже нельзя. Таким образом все информация о версии структуры БД хранится в ней самой, и можно обойтись без удаления пользовательских данных.

**III.** 

До

1.	Метод возвращает после поиска значение конкретного типа НЕ MayBe.

После

2.	Проводится код ревью над рефакторингом этого метода и мест его использующих. 
После рефакторинга возвращается тип MayBe. Если значения в нем нет, то на возвращается null.
Возникли сомнения, может ли по прикладной логике действительно возвращаться null, ведь ранее возвращался объект конкретного типа. 
Подумал, что просто поленились поднимать выше по цепочке вызовов рефакторинг типа на MayBe и воспользовались тем, что Java позволяет использовать null, хотя в изначальной логике его быть не может. 
Провалился внутрь метода поиска до рефакторинга и увидел, что ранее он тоже мог возвращать null, о чем я не думал, т.к. видел конкретный тип возвращаемого значения. Учитывая, что в Java уже появился Optional – его следует по максимуму использовать в подобных случаях, для понятности СД.

## Выводы
"Плохие программисты думают о коде. Хорошие программисты думают о структурах данных и взаимосвязях между ними". (c) Линус Торвальдс
