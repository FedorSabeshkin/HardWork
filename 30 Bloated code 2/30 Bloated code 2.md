## Идея
В коде можно встретить циклы, в теле которых одновременно происходит и суммирование элементов и поиск среди них максимального. 
Раскидывать это на 2 цикла, что бы явно разделить две такие разные логики не всегда возможно, например, когда массив данных столь большой, что даже два прохода по нему слишком дороги, или, как в случае с сетевым потоком, повторный проход невозможен.

В этом случае мы уже имеем некоторую запутанность кода. 
Нам от нее хорошо бы избавиться в общем случае, с помощью абстракции “исполнителя”, которому мы просто передавали бы массив и функцию которую надо над ним выполнить. Сами эти вызовы мы могли бы сделать по отдельности и явно именовать их в коде, как отдельные функции, например. А уже “исполнитель” фактически запускал бы только 1 цикл. 

То есть код поддерживаемый человеком выглядел бы читабельнее. 
Фактически, в Java что-то подобное происходит при оптимизации JIT.

Если в вашем языке программирования нет возможностей такого абстрактного исполнителя, то с запутанностью кода такого рода следует как минимум бороться пояснительным комментарием. 
То есть ваша задача как программиста - видеть поток данных и некоторые преобразования над ним, а не просто код лапшу, которую мог бы увидеть кто-то другой.

## Примеры
1. `// первая строка после заголовка таблицы`
```java
int row=1;
for(…){
…
}
```
2. `// Проверяем, что в список на удаление добавлены именно те данные, что были ранее на сущности. 
Иначе убрать их из запроса на удаление, что бы не нагружать систему.`

3.Ряд случаев, когда вызов в теле метода конструктора некоторой DTO следует вынести в фабрику, или отдельный конструктор этой DTO, который будет принимать более верхнеуровневые объекты и самостоятельно получать из них нужные для создания объекта поля. 

4. `// Выполняем сортировку для упрощения отображения в результирующие объекты`

5. `// Заполнение значений объекта фильтра`


## Вывод
Видно, что многие вещи можно вынести в отдельный метод, который уже снабдить понятным комментарием и названием, либо вынести в документацию как описание общего приема.   
Но есть **случаи на “стыке”, выразительности исходного кода и результата в момент исполнения**, например, когда в некоторых языках надо идти на компромис, как выполнение двух различных операций в теле одного цикла. 
