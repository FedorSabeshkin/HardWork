## Когда можно применить
Можно использовать подход, когда мы не расширяем через наследование опредленный класс, тогда когда в нем нет удобного механизма наследования.
Самый простой способ создание класса обертки.

## Пример
Реализация приложения для инвентаризации, приемки торава, проверки цен.  
Хорошо бы вынести общий функционал и далее подключать его и расширять постепенно, параметризировав общее.

Особенно важно было бы вынести в общую часть UI компоненты, т.к. на всех экранах есть общее:

Поле с текущим отсканированным ШК (штрихкод) Информация о товаре с данным ШК: Наименование, остаток, цвет/размер.

1. Делали этой создавая каждый раз новую страницу и дублирую большую часть кода верстки, зато имели уникальный идентификатор для каждой страницы по которому могли обращаться в контексте конкретного подприложения (инвентаризация/приемка/проверка цены)

2. Расммотрим конкретно инпут для ШК. У схожих элементов был общий суффикс в id, например "barcode", перед которым добавлялось название приложения, например, у приложения "price_checker", id для инпута ввода ШК был"price_checker_barcode". Соответсвенно общие методы, такие как считывание значения из инпута, параметризировались id конкретного приложения при входе в него.

3. Таким образом у нас были инпуты, будто бы одинаковые по своему коду, но имеющие каждый уникальные id, через которые ими можно было манипулировать.

В таком случае одинаковые по сути объекты - инпуты с методом чтения - различаются за счет присвоения им различных id.

Фактически, было бы проще просто генерировать каждый раз верстку для этого html из одной функции, а после использования - уничтожать этот объект. Либо воспользоваться готовы SPA фрэймфорком, который сам управляет жизненным циклом таких объектов.  

## Вывод

В бэкенде пример для схемы с заданием дополнительных id для одинаковых по
наполнению, но фактически разных объектов подобрать не смог.  

Bo frontend, где число схожих объектов в основном близко к тому, что человек может
обработать визуально, такая схема имеет место быть.

Фактически роль HashMaр по id объекта отдающая его здесь выполняется браузером: DOM и ЈЅ АРІ для работы с ним.  
