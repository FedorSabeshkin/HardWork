# Что такое абстракция?

## Идеи

+ Абстракцую можно подобрать всегда, но что бы она была хорошей надо выбрать такую, операции над которой будут схожи с операциями над реальным объектом.

То есть: смартфон можно представить в виде целого числа ІМЕІ, но увеличение этого числа на единицу не будет отображать, что мы получили смартфон большего размера.

Практически никакие операции с настоящего объекта не перешли на абстракцию. Но мы могли бы использовать эти идентификаторы, что бы отображать обмен смартфонами между людьми.   Но не его включение/выключение.

+ Абстракции привлекают нас возможностью легко рассуждать о сложных технических проблемах
через простые примеры, и через такие описания создавать реализации с богатой
функциональностью, но ни одна из существующих фичей конкретного языка программирования, будь то интерфейсы или функции не позволяют этого сделать в полной мере.   Мы можем мыслить глубже и опираться не на язык, а на конструирование в своей думательной машинки, которая позволит нам сначала очень приблизительно, а потом все точнее и точнее переводить происходящее в беспорядочном физическом мире в точные цифровые модели.

В таком случае, не опираясь на конкретные фичи и не споря о том, какие у нее есть плюсы и фатальные минусы, которые не позволяют говорить о ней, как об "абстракции", мы можем рассуждать глубже, и, как не парадоксально, наши определения будут точными.

То есть мы должны выйти за границы двоичного определения, того является, что либо "абстракцией" или нет, и выйти на новый семантический уровень (для тех кто знаком с 3 уровнями рассуждения о программе), на котором, как не парадоксально, наши определения будут точны.

Еще более точны, чем на уровне синтаксиса кода.

То есть мы включаем в наше определение не только Source code конкретного класса, но и readme.md, в котором описана его спецификация на более высоком уровне, с органичениями о которых мы не можем апрямую рассуждать в коде, как минимум по тому, что они разрушили бы всю идею SRP, но которые фактически присутсвуют при работе системы.

Кроме того, при рассуждении о реализации, обязательно будет обсуждаться как и где система эксплуатируется облако/классичесский серве/мобильное устройство, каковы аппаратные ограничения (кол-во ОЗУ, ядер, размер диска). Все эти вещи могут частично быть отражены в коде, а могут находиться уже на уровне эксплуатации, но при проектировании нам тем не меннее,

нужна абстракция такой системы, для проработки.

## Примеры

### Логика имеющая схожую реализацию, но различную спецификацию.

1. Есть несколько пакетов классов для автоматической генерации отчетов.

Отчеты отличаются как набором полей, источниками данных так и их визуальным представлением.

В одном из пакетов с помощью полиморфизма удалось сделать логику общей на 2 типа отчетов, но во многом код на каждый случай пришлось оставить уникальным, а обобщить только общую схему, добавив в нескольких местах ветвление с проверкой типа входящегo аргумента и выбором соответсвующего обработчика.

В данном случае дублирование фактически разного по спецификации функционала не было бы проблемой.

2. При обработке специфического поведения системы, добавить ветвление для кейса в уже существующем обработчике web hook, или выделение нового контроллера для вынесение логики, с дублированием части проверок, в этот новый обработчик и завязке на более узкое событие?

Тут лучше выбрать второй вариант, как минимум задав себе наводящий вопрос какую ответвенность будет иметь первый модуль при добавлении в него нового функционала, а какую второй.

3. DAO для изначально схожих view, у которых в будущем могут сильно измениться запросы, добавив доп. JOIN, например.

Р.S. Слышал, что на каждой конференции по Highload спрашивают о том, что делать, когда необъодимо поменять Primary key в существующей системе.

### При повышении полиморфности кода не скатывалось ли это все к "боксингу"?

Как уже заметил в пункте (1) да, разросся полиморфный класс, в который было из двух других классов перенесены несколько метододов, которые были уникальны для каждого кейса. Но универсальности строго говоря тоже добиться удалось.

А вот насколько она оправданна с точки зрения поправить два независимых файла или один, но с более сложной конструкцией, которая выбирает нужную реализацию другой вопрос :).

### Как часто в среднем в час приходится заглядывать в другие файлы, что бы понять смысл сущности/функции?

0-3-5-10, ну скорее, т.к.знаю проект, то раза 3, если смотрю менее известный модуль и 1, если уже знакомый.

Один из методов сокращения таких заглядываний, соответсвенно, иметь в голове абстрацию того, с чем работаю :). То есть хорошо знать проект.

Для сокращения необходимых знаний следить за соблюдением SRP в каждом модуле и классе.
