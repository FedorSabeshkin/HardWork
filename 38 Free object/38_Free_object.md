# Free Object. Добиваемся совместимости между (унаследованными) типами


## Анализ

На мейнстримном уровне это напомнило мнe feature flags, когда мы оставляем системе возможность работать по старому, если с новым функионалом что-то пойдет не так.   
Журналирование позволяет нам выполнить рефакторинг из А в Б с отслеживанием поведения, а если что-то в этом преобразовании пошло не так, то выполняем откат во времени и направляем поток вычислений работать по старому или по уже обновленному преобразованию, в котором убрали ошибку.

Аналогично, ценятся криптовалюты с историей всех перемещений стредств.

## Примеры

1. Наш бот стал неправильно двигать задачи по flow, из-за чего пришлось переносить планирование спринта.

    а) _Подход через feature flag и канареечны релизы_ - снизить эффект от внедрения ПО с возможным багом, делая его внедрение постепенным, расскатывая для начала на 1-2-5% клиентов и при необходимости переключаясь на старую версию.
Возможные ошибки оставляем как есть для индивидуально изменения, например через перенос планирования спринта и ручного задания flow для задач.

    б) _Подход историчности._   
    Раскатали ПО, (можем так же на 1-2-5% клиентов), если что-то пошло не так, то отключили новый функционал и запустили команду, по которой ПО откатит свои действия выполненные по новому алгоритму с момента релиза и проведет их по старому.

### Git

2. Мы вливаем в develop только после того как прошли все юнит тесты и IT, объединяя все изменения по задаче в один коммит и используя rebase, так что вся наша история git ровная и позволяет выполнять переключение в историчности между фичами. В данном контексте, наш develop это free object.

3. Пока я разрабатываю в своей ветке:  
а) Стараюсь делать коммит на каждое сколько нибудь атомарное изменение, которое не всегда позволяет прохождение тестов или сборку.  
б) Перед тем как передавать код на ревью я объединяю все коммиты в один.   
в) По ревью можно выполнить изменение, которое добавляю к основной задаче через amend к существующему коммиту и после которого может оказаться что тесты не проходят, т.к. в ревью и сам разработчик могли чего-то не учесть.   
г) Вместо того, что бы тривиально откатить лишнюю доработку, если бы она была в отдельном коммите, приходиться пользуясь инструментами GitLab и собственной памятью, делать это в ручном режиме.   

    Тут free object при работе в ветке по задаче после передачи в ревью - не реализован.
Было бы удобно иметь одновременно публичную историю изменений по задаче (один коммит, который вольется в develop) и приватную (коммиты, которые затем объеденились в этот один, и которыми легко манипулировать при разработке). 
Сейчас же используется один вариант ИЛИ другой.

## Краевой случай  
На стыке рассматривания программы на уровне кода и рассматривания ее в runtime и уровне спецификации.
\+ Логирование позволяет и помогает нам понять поток выполнения достаточно подробно и увидеть где произошла ошибка, что бы в том числе выполнить компенсирующие действия.
\- Мы не можем логировать персональные данные по нормам безопасности.

## Итог 

Концепция дает больший контроль в процессе развития программы, но требует в идеале своего спец языка для описания выполненных действий, который затем можно передать в "машину времени", для выполнения компенсирующих действий. 

Кроме того, некоторые действия нельзя скомпенсировать. Например сжигание некоторого кол-ва топлива уже нельзя откатить обратно.
