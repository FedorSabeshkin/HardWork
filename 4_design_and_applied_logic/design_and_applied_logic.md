## Единственность дизайна под конкретные требования
### Задание
Требуется, что бы конкретному логическому дизайну
мог соответсвовать только один код - то есть что бы задачу можно было решить,
только использованием единственной комбинации
и в единственном порядке предоставляемых (проектировщиком/разработчиком) методов системы.

### Используемые определения
*ПЛ - прикладная логика.*
### Анализ
#### Формулирование логического дизайна кода на русском языке
Была реализована фича смены статуса на (Y) Сущности (2), при смене статуса Сущности (1) на (Y).
При этом, смены статуса на (Y)
для Сущности (2) выполнялось отдельным методом change_status_2 и подразумевалось,
что проверки требуемые для него будут выплнены
в методе смены статуса сущности (1) change_status_1 на (Y),
который по ПЛ обязательно выполняется перед ним.
#### Соответсвие код словесному описанию
Фактически, на уровне кода, программист мог удалить предшествующий change_status_1
и вызвать change_status_2 без проверок, что могло выкинуть неожиданное исключение.
#### Решение
Было принято решение, функционал смены статуса на (Y) Сущности (2)
добавить в метод смены статуса на (Y) для Сушности(1) ,
и выделить из метода смены статуса change status_1,
отдельный метод смены статуса на (Y) сущности (1) change_status_to_Y_1,
который так же будет выполнять смену статуса на (Y) для  сущность (2) - change_status_2.

Важно, что не из всех мест может вызываться метод смены статуса на (Y) Сущности (1) тем не менее,
не получится передать аргументы на смену статуса на (Y),
т.к. это валидируется, до вызова этого метода.

Поэтому, если идет в ветку смену статуса на (Y), значит клиент вызывающий этот метод имеет на это полномочия.  
Потому не стал добавлять некое расширение,
в котором в декларативном стиле задавали бы какие клиенты имеют возможность вызывать данный метод.

С другой стороны, из имеющих полномочия клиентов, все еще возможно вызвать метод change_status_1,
nередав туда смену статуса на (Y)
который будет выполнен не корректно, т.к. не будет вызова change_status_2. Скорее всего,
понадобится добавлять проверку переданного статуса в change_status_1
и при необходимости выбросывать исключения с информацией о требуемом методе,
если этим методом пытаются вызвать для смены статуса на (Y).

Сразу после проверки в change_status_1 я не могу вызывать change_status_2,
т.к. для этого метода требуется дополнительный
аргумент с клиента, который не используется в change_status_1.
Добавление в сигнатуру change_status_1 нового аргумента,
который будет использоваться только в одном случае,
посчитал некрасивым и запутывающим,
хотя сейчас вижу, что так поведение было бы надежнее.
Надо продумать третье решение,
что бы исключить возможность вызова change_status_1 со статусом на (Y),
которое в текущей реализации приведет к ошибке.
Сокращать дипазон возможно передаваемых туда статусов Сущности (1),
вводя новый enum без статуса (Y) - кажется не очень хорошим решением,
которое сейчас и выглядит отражающим ПЛ,
т.к. для смены статуса на (Y) обработка действительно отличается,
но тем не менее разрушает множество возможно принимаемых значений
Сущности (1).

#### Сводные данные
Была выполнена 1 итерация.  
Время: 6ч сфокусированной работы.  
Объем LOC: 1350.
