## Устранение влияния антипаттерна "самодокументирующийся код"
### Используемые определения
*Анализ - процесс мышления, в близком к хронологическому порядку, по которому я пришел к решению*

### Задание
Есть расхожее мнение о "самодокументирующемся коде", но учитывая, что в коде может быть отражена только текущая реализация, в чем безусловны плюс, в сравнении с могущими устареть комментариями.  
В нем не может быть отражен весь дизайн системы, т.к. **код не должен знать ничего о взаимодействии других модулей между собой, иначе это разрушает саму идею инкапсуляции**, однако эта информация полезна для разработчиков и тех. писателей.  
Для решения нам периодически требуется писать комментарии, которые сообщали бы о том, какое значение данный класс/метод несет для всей системы.  

### Решение
1. *До:*  
Ошибка проверки валидного объекта 1    
*После:*  
Ошибка возникающая при проверке объекта_1 на контуре_1, 2.

2. *До:*  
(1) Приложение контура_1, обработка объекта_1  
(2) Приложение контура_1, обработка объекта_1     
*После:*  
(1) Приложение контура_1, выполнение функции_1 над объектом_1     
(2) Приложение контура_1, выполнение функции_2 над объектом_1

3. *До:*  
Приложение контура_1  
*После:*  
Приложение контура_1, выполнение функции_2, инициируемого контуром_3

### Анализ
#### Понимание общей архитектуры системы.
Первый вопрос: текущие комментарии описывают, как класс вписывается в общую архитектуру системы? 
Мне кажется, что да, потому что у меня в близкой памяти есть вся архитектура системы. Когда я вижу сервис_1,
я знаю, что это тот сервис сервис_1, который используется при обработке процессов в контуре_1.  
Если бы я не знал еще о существовании контура_1, то мог бы строить разные гипотезы.   
С другой строны, когда только стал разбирать проект, 
для меня достаточным было видеть схему системы на которой верхнеуровнево нарисованы контура 
и сервисы к которым они обращаются и как происходит общение между контурами.   
На этой диаграмме использовались такие же обозначения как и названия модулей (папок) в коде:  
контур_1, контур_2, контур_3, контур_4, сервис_1, сервис_2 и т.д.
 
Я ознакомившись с это схемой далее начал самостоятельно разбирать код 
и достаточно просто ассоциировал код/модуль с тем, за какую часть системы он отвечает.  
Объем проекта был ~100 т. строк.

#### Понимание взаимодействия классов в конкретном модуле
Тут сложнее так как изначально не рассматривал графическую схему такого более детального вида.  
Зато при реализации видны паттерны, по которым можно понять взаимодействие классов в системе.  

Слабое место которое приходит на ум реализация нового метода в сервисе, 
для которого надо знать всю цепочку и хотя бы знать, что искать.   
При живом общении возможно быстро объяснить идею по которой организуются классы в модуле, 
а в дальнейшем описать это в Wiki проекта.  
Пересмотрел статьи кодичной давности и они все еще полезны.    

В таких сложных взаимодействия, в сами комментарии над классом в модуле, 
можно указать ссылку на связанную с модулем статью в Wiki.   
Описание не такое лаконичное, как в комментарии, зато и не ограниченное им.   

**Заметка** Для еще большей уверенности в том, что я правильно понял, 
при самостоятельном разборе кодовой базы мне было бы удобно, если бы в комментарии описывалось, 
что именно класс делает, то есть опускание до реализации как ни странно. Но и дизайн системы здесь так же бы отражался, 
когда указывали бы откуда именно пришли входные аргументы, например, и где будет использован ответ метода.  
Как правило я легко ассоциировал модуль/папку с его реальной ролью в системе.


#### Один из методов для формирования полезного комментария
Увидел новый модуль_2, судя по названию,  
обрабатывающий специфический кейс или часть функционала, который был в модуле_1, который все еще существует.  
Комментарий в нем, был таким же как и в классе из модуля_1.  
Разницу удалось понять, когда открыл commit message, которым был создан класс.   
В нем содержалась информация о том, какую роль этот модуль_2 имеет в системе в целом.  

Продублировал в комментарий, т.к. такая мета информация из коммита может потеряться, 
при переносе файла из одной директории в другую, когда git решит, что это новый файл.

