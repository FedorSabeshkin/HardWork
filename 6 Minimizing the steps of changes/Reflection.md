## Рефлексия. 

Прежде редко когда писал сначала тест, а только затем создавал в классе метод с требуемым названием и сигнатурой. 
Хотя в книге TDD эта идея меня в свое время поразила, что ошибки от компилятора могут нам так помогать.

Коммитов я делаю определенно больше, ибо коммичу теперь на каждый чих, раз в 10 больше (:.

![image](https://github.com/FedorSabeshkin/HardWork/assets/37352353/5331802f-afac-4aa0-891b-7353b5bcfa49)


Если ошибка была опиской, вроде того что скопировал код старого теста, для написания теста на новый метод
и не поменял в теле теста вызов старого метода на новый, хотя изменил ожидаемый результат и тест упал - то не переписывал его.

Периодически копировал код, который не хотел коммитить, т.к. он не был до конца готов,
 но который потребуется в блокнот и удалял перед коммитом из основного файла.
 
Был произведен один откат до исходного состояния

В коммите в котором выполняю реализацию надо писать минимум по два тест кейса, вместо проверки на работоспособноть того одного,
что прежде работал на константе. Это требуется что бы не забывать добавлять реализацию к методам.

Стоит ли удалять код, когда ошибка в нем, только в том, что метод который он в себе вызывает от другого класса
на деле был реализован через мок/возврат константы?
Вроде как не стоит, т.к. ошибка в методе другого класса, который реализовывался еще 10 коммитов назад и прекрасно работает на свой тест.

Еще одна ошибка была в коде, который скопировал из интернета 10 коммитов назад. Было выявлено написанием дополнительного теста, без изменения кода 
крайней успешной ревизии, поэтому откатывать код на 10 коммитов назад не стал

На задачу простого декодирования из точек и тире кода Морзе в латиницу потребовалось 18 коммитов, ожидал меньшего.

В настоящем рабочем процессе коммиты я делаю реже, в основном пока не завершу некую достаточно объекмную часть. Примерно раз в 3 часа.

Меньше тесты сделать сложнее, т.к. разбивал их на минимальные шаги:
1. Тест вызова метода с требуемой сигнатурой и возвратом некого константного значения
2. Если реализация метода требует других методов, то повторяю для них шаг 1, пока не смогу перейти к шагу 3(от метода на самом нижнем уровне, которуму уже не требуются дополнительные).
3. Тест на корректность полной реализации метода

В этой схеме на 3 шаге можно было добавить между возвратом константы и полной реализации метода
промежуточную реализацию, когда есть некая логика на несколько тестовых значений, опять же как в книге по TDD.
Но конкретно в моем случае это не потребовалось, т.к. решение задачи при реализации метода уже было понятно.  
Во второй задаче выполнил бы их так же. Возможно только обратился бы к использованию частичной реализации.

Тренировался на этой задаче
https://www.codewars.com/kata/decode-the-morse-code
По первой задаче было выполненно 19 изменений.

